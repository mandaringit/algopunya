# [BOJ] 2206

- [ ] PYTHON
- [x] JAVASCRIPT

#### BFS

일반적인 미로찾기와 비슷한 문제이고 거리를 단계적으로 증가시켜야 하기 때문에 BFS를 생각했다. Queue의 경우 front와 rear 변수를 통해 pop()에 걸리는 시간에 걸리지 않도록 구현했다.

과거 파이썬으로 풀때는 재귀적으로 못가면 돌아오는 식으로 풀었는데 아마 벽을 뚫는 상태를 잘 못 표현한 부분이 있어서 시간초과나 틀리지 않았나 싶다.

#### 시작칸과 끝나는 칸도 포함해서 센다.

시작과 끝도 고려해야 한다는 점을 인식한다.

#### 벽을 부수고 이동할 수 있다

다른 미로찾기와 다른 부분이 바로 이 부분인데, 벽을 부수고 가는 경우를 기억해야 한다.

그렇기 때문에 체크 배열을 3차원으로 구현한다. 3차원이라고 어렵게 생각할건 없다. 기존 2차원 배열에서 숫자 `0` 또는 `1`로 방문 여부를 체크하던 방식을 배열 `[0, 0]`으로 표기한다.

배열에서 각 인덱스별 의미는 다음과같다.

- 3차원의 0번째 인덱스인 `checked[i][j][0]`은 맵의 `[i][j]`번째에 도달할때 벽을 뚫지 않고 도착한 거리이다.
- 3차원의 1번째 인덱스인 `checked[i][j][1]`은 맵의 `[i][j]`번째에 도달할때 벽을 뚫고 도착한 거리이다.

**예제 입력이 아래와 같은 경우 진행 모양을 살펴보자.**

```text
3 3
010
011
010
```

진행되는 모습을 통해 어떻게 가는지 확인해보자.

```py
# 시작 위치(0,0,0) 를 1로 만들고 큐에 넣어 진행한다.
[
  [ [ 1, 0 ], [ 0, 0 ], [ 0, 0 ] ],
  [ [ 0, 0 ], [ 0, 0 ], [ 0, 0 ] ],
  [ [ 0, 0 ], [ 0, 0 ], [ 0, 0 ] ]
]

# 시작점 이후 큐에 들어간 모습
#  [
#   [ 0, 0, 0 ],
#   [ 0, 1, 1 ], 벽이 있는 곳을 들렸다면 벽을 부쉈으므로 큐에 (i,j,1)이 들어간다.
#   [ 1, 0, 0 ] 벽이 있는 곳을 들리지 않았다면 (i,j,0)이 들어간다.
# ]

# 그리고 각각의 인덱스에 이전 위치 + 1 하여 진행한다.

[
  [↓[ 1, 0 ],→[ 0, 2 ], [ 0, 0 ] ],
  [ [ 2, 0 ], [ 0, 0 ], [ 0, 0 ] ],
  [ [ 0, 0 ], [ 0, 0 ], [ 0, 0 ] ]
]
[
  [ [ 1, 3 ], [ 0, 2 ],→[ 0, 3 ] ],
  [ [ 2, 0 ], [ 0, 0 ], [ 0, 0 ] ],
  [ [ 0, 0 ], [ 0, 0 ], [ 0, 0 ] ]
]
[
  [ [ 1, 3 ],↓[ 0, 2 ], [ 0, 3 ] ],
  [↓[ 2, 0 ], [ 0, 3 ], [ 0, 0 ] ],
  [ [ 3, 0 ], [ 0, 0 ], [ 0, 0 ] ]
]

# 되돌아 가는 경우.
[
  [ [ 1, 3 ], [ 0, 2 ], [ 0, 3 ] ],
  [ [ 2, 4 ],←[ 0, 3 ], [ 0, 0 ] ],
  [ [ 3, 0 ], [ 0, 0 ], [ 0, 0 ] ]
]
[
  [ [ 1, 3 ], [ 0, 2 ], [ 0, 3 ] ],
  [ [ 2, 4 ],↓[ 0, 3 ], [ 0, 0 ] ],
  [ [ 3, 0 ], [ 0, 4 ], [ 0, 0 ] ]
]

# 여기서 [2][0][1] 요소를 보면 되돌아서 왔지만(5) 옆으로 가려고 해도,
# 이미 더 빠른 경로로 도착해 방문 체크 되어 있으므로 더이상 가지 않는다.
# 더 긴 거리로 덮어 씌워지지 않는다는것.
[
  [ [ 1, 3 ], [ 0, 2 ], [ 0, 3 ] ],
  [↓[ 2, 4 ], [ 0, 3 ], [ 0, 0 ] ],
  [→✖️[ 3, 5 ],[ 0, 4 ], [ 0, 0 ] ]
]

#  마지막 도착.
[
  [ [ 1, 3 ], [ 0, 2 ], [ 0, 3 ] ],
  [ [ 2, 4 ], [ 0, 3 ], [ 0, 0 ] ],
  [ [ 3, 5 ], [ 0, 4 ],→[ 0, 5 ] ]
]
```
