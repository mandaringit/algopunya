# [LEETCODE] Sudoku Solver

스도쿠 풀기 (배열 그대로 변환)

### 백트래킹

백트래킹 풀이를 참고했다. 코드가 다소 길어 머뭇거릴 수 있지만 이 역시 내부 원리는 동일하다고 생각한다.

1. 풀 자리를 찾는다 ('.')
2. 문제를 푼다. 가능한 경우를 시도해보면서 스도쿠의 규칙에 맞는지 (가로, 세로, 해당 사각형) 확인한다.
3. 만약 가능한 경우라면 보드에 해당 수를 표시한다.
4. 다음 문제를 푼다. `self.solve()`
5. 푼게 문제가 없다면 True를 리턴하고, 뭔가 문제가 있다면 원상 복귀 후 False를 리턴한다.

3 ~ 5 단계, 이 부분이 헷갈린다.

일단 `solve()`가 재귀적으로 호출되면 그 아래 라인들은 일단 실행 자체가 되지 않는다. 즉 다음 단계로 계속해서 나아가는 모양이다.

```py
for num in ["1", "2", "3", "4", "5", "6", "7", "8", "9"]:
  if self.isSafe(row, col, num):
      self.board[row][col] = num
      if self.solve():
#  -------------------- 위의 self.solve()가 무언가를 리턴하기 전까진 이 아래로 진행 안함
          return True
      self.board[row][col] = "."  # 이전단계 마킹 없애기
return False
```

이렇게 계속해서 `solve()` -> `solve()` -> `solve()` 하다가 만약 해당 row,col에 어떤 num도 들어갈 수 없는 경우 `False`를 리턴하게 되는데, 그렇게 되면 이전 단계에서 답을 잘 못 쓴것이기 때문에 돌아가야 한다. `self.board[row][col] = "."`

그러나 이렇게 False를 리턴하지 않고 계속해서 풀어나가다 보면 빈자리가 없어지고, 종료 조건에 걸리게 된다.

```py
if row == -1 and col == -1:
    return True
```

그렇다면 마지막으로 호출된 `solve()`는 True를 리턴하게 될 것이고, 비로소 다른 `solve` 함수들도 True를 리턴해가며 거꾸로 콜스택을 전부 빠져나가 함수가 종료되게 될 것이다.
