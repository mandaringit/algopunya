# [LEETCODE] Counting Bits

`0 <= i <= num`의 정수 i들의 2진수 표현의 1의 갯수 세기 (시간 O(N) & 공간 O(N))

### 접근

핵심은 어떤 정수를 이진수로 표현했을 때 1의 갯수를 어떻게 계산하느냐이다. 이 부분만 해결하면 순회하면서 모든 수를 구하면 된다.

- 비트 변환
  바로 생각나는 방법은 `정수 & 1` 로 1이 나오면 1을 포함하므로 카운트, 이후 `정수 >> 1` 로 비트를 한칸씩 옮기면서 진행했다. O(N \* 정수의 이진수 길이)만큼의 시간이 걸린다.

- DP O(N)
  왜 DP일까 생각해봤는데, 정수 A가 가진 1의 갯수 = 정수 A를 2로 나눈 나머지(0 또는 1) + 몫이 이미 가지고 있던 1의 갯수와 동일하다.

  5를 예로 들어보자. 5 = 101로 1이 두개다.

  5를 2로 나눈 몫은 2, 나머지는 1이다. 그러면 일단 나머지가 1이기 때문에 1의 갯수가 하나 추가되고, 거기에 몫인 2(2진수 10)의 1의 갯수 1을 하나 더 더하면 답인 두개가 나온다.

  즉 101을 (1)(01)로 보는 방법이다.

  0부터 시작해서 올라가는 bottom up 방식이므로 항상 자신보다 작은 몫의 dp값은 존재한다.

  ```text
  dp[num] = dp[num을 2로 나눈 몫] + num을 2로 나눈 나머지
  ```
