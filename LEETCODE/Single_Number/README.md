# [LEETCODE] Single Number

모든 수가 하나를 제외하고 중복되서 나타날때, 그 수를 찾아라.

### 접근

찾는거야 쉽지만 O(N)의 시간으로, 추가적인 공간을 사용하지 않고 풀어야 한다.

- 정렬 후 탐색
  길이와 수의 범위도 크기 때문에 그나마 생각나는건 정렬 O(NlogN) 후 0부터 시작해 2칸씩 뛰면서 nums[i], nums[i+1]번째 값이 다를때 nums[i]의 값을 리턴하는 것이다.

  추가 공간은 사용하지 않지만 최악의 경우 O(N^2)이라는 점이 조금 그렇다.

- XOR 사용하기

  다른 사람들의 풀이를 보니 XOR의 특징을 사용한 풀이가 있었다. 동일한 수를 XOR 하는 경우 0이된다. `3 ^ 3 = 0`

  즉, 모든 수를 XOR하면 결과적으로는 마지막에 남는 수가 혼자 있던 수가 된다. 이렇게 하면 O(N)으로 문제를 풀 수가 있게 된다.

- 합을 이용하기
  중복을 제외한 수들의 합의 2배 - 현재 배열 값을 빼면 중복되지않은 수가 나온다.
  O(N)으로 가능.
